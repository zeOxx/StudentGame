using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Media;
using Perihelion;

namespace Perihelion.Models
{
	class Gameworld : Microsoft.Xna.Framework.Game        // TODO SINGLETON
	{
		// the max int will be used when making levels in the editor, so it's unused at the moment
		const int numOfMaxCollidables = 10;
		// current will also be used in the editor eventually, but for now it's set to const and
		//  is used as a max for testing purposes
		

		int levelSize = 4096;

        private int score;
		private Player playerObject;
		private Boolean drawWell;
		private GameObject gravityWell;
		private List<Collidable> rocks = new List<Collidable>();
		private Background background01;
		private Background background02;
		private Camera camera;
		private spawnEnemies enemy;
		private HUD hud;
		private Rectangle levelBounds;
		private Controllers.ParticleSystem particleSystem;
		private List<Enemy> enemies = new List<Enemy>();
		private Controllers.UnitHandler unithandler = new Controllers.UnitHandler(); //WIP - mostly empty
		private bool debug;

		public Gameworld(ContentHolder contentHolder, Viewport view, int levelSize)
		{
			particleSystem = new Controllers.ParticleSystem();
			initializeGameworld(contentHolder);
			camera = new Camera(view);
			hud = new HUD(contentHolder, camera);
			LevelSize = levelSize;
			Debug = false;
		}

		public Controllers.ParticleSystem getParticleSystem()
		{
			return particleSystem;
		}

		public Player getPlayer()
		{
			return playerObject;
		}

		public void setPlayer(Player updatedPlayerObject)
		{
			playerObject = updatedPlayerObject;
		}

		public Player PlayerObject
		{
			get { return playerObject; }
			set { this.playerObject = value; }
		}

		public GameObject GravityWell
		{
			get { return gravityWell; }
		}

		public int LevelSize
		{
			get { return this.levelSize; }
			set { this.levelSize = value; }
		}

		public Rectangle LevelBounds
		{
			get { return this.levelBounds; }
			set { this.levelBounds = value; }
		}

		private bool Debug
		{
			get { return this.debug; }
			set { this.debug = value; }
		}

        public int Score
        {
            get { return this.score; }
            set { this.score = value; }
        }

#if DEBUG
		public void setDebug()
		{
			if (hud.DisplayDebug)
			{
				hud.DisplayDebug = false;
				Debug = false;
			}
			else
			{
				hud.DisplayDebug = true;
				Debug = true;
			}
		}
#endif

		private void initializeGameworld(ContentHolder contentHolder)
		{
			playerObject = new Player(  contentHolder.texturePlayer, 
										contentHolder.texturePlayerTurret, 
										contentHolder.texturePlayerBullet, 
										contentHolder.texturePlayerSpecal01,
									  0, 0, Vector2.Zero, 100);

			gravityWell = new GameObject(contentHolder.textureGravityWell,
										 playerObject.Position.X,
										 playerObject.Position.Y,
										 Vector2.Zero,
										 0);

			levelBounds = createBounds();
			background01 = new Background(contentHolder.bg_variant0, playerObject.Velocity, levelBounds, 0, 0, 0.4f);
			background02 = new Background(contentHolder.bg_variant1, playerObject.Velocity, levelBounds, 0, 0, 0.2f);

			// The following should (and will, eventually) be loaded by reading a file generated by an editor,
			//  so this is temp, testing etc
			particleSystem.newEmitter(contentHolder.particle_smoke, getPlayer().Position, 0, 200, 12, false, getPlayer().Velocity);

			
			

			rocks.Add(new Collidable(contentHolder.textureRock01,  150,  300, Vector2.Zero, true, 600));
            rocks.Add(new Collidable(contentHolder.textureRock02, -250, -330, Vector2.Zero, true, 400));
            rocks.Add(new Collidable(contentHolder.textureRock01, 500, 300, Vector2.Zero, true, 100));
            rocks.Add(new Collidable(contentHolder.textureRock02, -100, 250, Vector2.Zero, true, 250));

			rocks.Add(new Collidable(contentHolder.textureRock01, 0, -250, new Vector2(0, -2), true, 200));


            
            //for (int i = 0; i < 20; i++)
            //{

            //    enemies.Add(new Enemy(contentHolder.textureEnemy01, contentHolder.texturePlayerTurret, contentHolder.texturePlayerBullet, i * 20 + 200, i * 20 + 200, Vector2.Zero, 1000));
            //}
		}

		// Creates the bounds for the level
		//  KEEP IN MIND THAT THE SIZE HAS TO ADHERE TO THE POWER OF TWO!
		//  THAT MEANS 8,16,32,64,128 etc etc
		private Rectangle createBounds()
		{
			Rectangle tempRect = new Rectangle(-(LevelSize / 2), -(LevelSize / 2), LevelSize, LevelSize);
			return tempRect;
		}

		public void Draw(SpriteBatch spriteBatch)
		{
			background01.Draw(spriteBatch);
			background02.Draw(spriteBatch);

			for (int i = 0; i < rocks.Count; i++)
			{
				rocks[i].Draw(spriteBatch, Debug);
			}

			foreach (Enemy enemy in enemies)
			{
				enemy.Draw(spriteBatch, Debug);
			}

			particleSystem.Draw(spriteBatch);
			playerObject.Draw(spriteBatch, Debug);
			hud.Draw(spriteBatch, Debug);
			if (drawWell)
			{
				gravityWell.DrawScale(spriteBatch, playerObject.WellStatus, Debug);
			}
		}

		public void update(GameTime gameTime, ContentHolder contentHolder)
		{
			camera.update(playerObject, gameTime);
			background01.update(playerObject.Velocity);
			background02.update(playerObject.Velocity);
			hud.updateHudPositions(camera);
			hud.update(playerObject);
			particleSystem.update(gameTime, getPlayer().Position, getPlayer().Velocity);

			gravityWell.Position = playerObject.Position;

            Vector2 vectorBetweenEnemyAndPlayer = new Vector2();
			//System.Console.WriteLine("X = " + gravityWell.Position.X + " Y = " + gravityWell.Position.Y);
            Vector2 playPos = new Vector2();
			for (int i = 0; i < rocks.Count; i++)
			{
				rocks[i].updatePosition();
			}
            playPos = playerObject.Position;

            for (int i = 0; i < enemies.Count; i++)
            {
                enemies[i].updatePosition(); 
                vectorBetweenEnemyAndPlayer.X = (playerObject.Position.X - enemies[i].Position.X);
                vectorBetweenEnemyAndPlayer.Y = - (playerObject.Position.Y - enemies[i].Position.Y);

                enemies[i].update(vectorBetweenEnemyAndPlayer, gameTime, false);   
            }

		}

		//Returns camera to draw function
		public Camera getCamera()
		{
			return camera;
		}

		public List<Collidable> getRock()
		{
			return rocks;
		}

		public List<Enemy> EnemyList
		{
			get { return enemies; }
		}

        //public void updateEnemies(GameTime gameTime)
        //{
        //    foreach (Enemy enemy in enemies)
        //    {
        //        Vector2 stick = unithandler.getEnemyStickVector(PlayerObject, enemy);
        //        int shot = unithandler.getEnemyTarget(PlayerObject, enemy);
        //        bool rocket = false;
        //        if (shot == 0)
        //        {
        //            enemy.update(Vector2.Zero, stick, gameTime, rocket);
        //        }
        //        else if (shot == 1)
        //        {
        //            enemy.update(unithandler.restrictEnemy(enemy, stick), stick, gameTime, rocket);
        //        }
        //        else
        //        {
        //            enemy.update(Vector2.Zero, Vector2.Zero, gameTime, rocket);
        //        }
        //    }
        //}
		
		public void setDrawGravityWell(bool draw, float wellStatus)
		{
			drawWell = draw;
			playerObject.WellStatus = wellStatus;
		}

        public void spawnEnemiesAtRandom(ContentHolder contentHolder)
        {
            Random randGen = new Random();

            int screenWidth     = 1280;
            int screenHeight    = 720;
            int randomXPosition = randGen.Next(-screenWidth , screenWidth / 2);
            int randomYPosition = randGen.Next(-screenHeight , screenHeight / 2);
            int spawnDirection  = randGen.Next(1, 5);
            int randomHealth    = randGen.Next(100, 301);
            Vector2 direction   = new Vector2();
            Vector2 spawnPosition = new Vector2();
            int numberOfEnemies = randGen.Next(4, 9);

            switch (spawnDirection)
            {
                //Top
                case 1:
                    spawnPosition.X = randomXPosition;
                    spawnPosition.Y = playerObject.Position.Y - screenHeight;
                    direction       = new Vector2(0, -2);
                    break;

                //Right
                case 2:
                    spawnPosition.X = playerObject.Position.X + screenWidth;
                    spawnPosition.Y = randomYPosition;
                    direction       = new Vector2(-2, 0);
                    break;

                //Bottom
                case 3:
                    spawnPosition.X = randomXPosition;
                    spawnPosition.Y = playerObject.Position.Y + screenHeight;
                    direction       = new Vector2(0, 2);
                    break;

                //Left
                case 4:
                    spawnPosition.X = playerObject.Position.X - screenWidth;
                    spawnPosition.Y = randomYPosition;
                    direction       = new Vector2(2, 0);
                    break;
            }

            //Magic numbers ftw. 
            //direction = 3;
            int offsetPosition = 32;
            for (int i = 0; i < numberOfEnemies; i++)
            {
                enemies.Add(new Enemy(contentHolder.textureEnemy01, contentHolder.texturePlayerTurret, contentHolder.texturePlayerBullet, 
                                      spawnPosition.X + offsetPosition, 
                                      spawnPosition.Y + offsetPosition, 
                                      direction * 0.8f, 
                                      randomHealth));

                offsetPosition += 32;
            }
            
        }
	
	}

	

	
}
